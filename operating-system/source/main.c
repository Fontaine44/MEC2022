/* DO NOT EDIT THIS FILE */

#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "image.h"
#include "log.h"
#include "pipeline.h"

static void show_help(FILE* f, const char* exec_name) {
    fprintf(f, "Usage: %s [OPTION]...\n", exec_name);
    fprintf(f, "\n");
    fprintf(f, "Options:\n");
    fprintf(f, "  --directory PATH                path to read and write images\n");
    fprintf(f, "  --pipeline [serial|pthread|tbb] pipeline algorithm to use\n");
}

static void fail_missing_argument(const char* exec_name, const char* opt) {
    fprintf(stderr, "%s: option '%s' requires an argument\n", exec_name, opt);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_unknown_argument(const char* exec_name, const char* opt) {
    fprintf(stderr, "%s: unrecognized option '%s'\n", exec_name, opt);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_unknown_pipeline_algorithm(const char* exec_name, const char* arg) {
    fprintf(stderr, "%s: unrecognized argument '%s' for option `--pipeline`\n", exec_name, arg);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static void fail_multiple_pipeline(const char* exec_name) {
    fprintf(stderr, "%s: zero or one option `--pipeline` must be specified\n", exec_name);
    fprintf(stderr, "Try '%s --help' for more information.\n", exec_name);
    exit(1);
}

static image_dir_t image_dir = {.load_current = 0, .stop = false};

static void sigint_handler(int sig) {
    printf("\n\rSIGINT received, stopping pipeline\n");
    image_dir.stop = true;
}

int main(int argc, char* argv[]) {
    char* exec_name           = argv[0];
    bool use_pipeline_serial  = false;
    bool use_pipeline_pthread = false;
    bool use_pipeline_tbb     = false;
    int use_pipeline_count    = 0;

    for (int i = 1; i < argc; i++) {
        if (strcmp("--directory", argv[i]) == 0) {
            if (i > argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            image_dir.name = argv[++i];
        } else if (strcmp("--pipeline", argv[i]) == 0) {
            if (i > argc - 1) {
                fail_missing_argument(exec_name, argv[i]);
            }

            if (strcmp("serial", argv[i + 1]) == 0) {
                use_pipeline_serial = true;
                use_pipeline_count++;
            } else if (strcmp("pthread", argv[i + 1]) == 0) {
                use_pipeline_pthread = true;
                use_pipeline_count++;
            } else if (strcmp("tbb", argv[i + 1]) == 0) {
                use_pipeline_tbb = true;
                use_pipeline_count++;
            } else {
                fail_unknown_pipeline_algorithm(exec_name, argv[i + 1]);
            }

            i++;
        } else if (strcmp("--help", argv[i]) == 0) {
            show_help(stdout, exec_name);
            exit(0);
        } else {
            fail_unknown_argument(exec_name, argv[i]);
        }
    }

    if (use_pipeline_count > 1) {
        fail_multiple_pipeline(exec_name);
    }

    if (use_pipeline_count == 0) {
        use_pipeline_serial = true;
    }

    if (signal(SIGINT, sigint_handler) == SIG_ERR) {
        LOG_ERROR_ERRNO("signal");
        exit(1);
    }

    printf("Starting image pipeline, press CTRL+C to stop loading images\n");

    int ret;
    if (use_pipeline_serial) {
        image_dir.save_prefix = "serial";
        ret                   = pipeline_serial(&image_dir);
    } else if (use_pipeline_pthread) {
        image_dir.save_prefix = "pthread";
        ret                   = pipeline_pthread(&image_dir);
    } else if (use_pipeline_tbb) {
        image_dir.save_prefix = "tbb";
        ret                   = pipeline_tbb(&image_dir);
    } else {
        LOG_ERROR("no pipeline configured");
        exit(1);
    }

    return (ret < 0) ? 1 : 0;
}
